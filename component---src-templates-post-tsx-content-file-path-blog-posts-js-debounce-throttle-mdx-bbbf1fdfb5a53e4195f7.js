"use strict";(self.webpackChunkhomepage=self.webpackChunkhomepage||[]).push([[2409],{9095:function(n,a,s){s.r(a),s.d(a,{Head:function(){return y},default:function(){return f}});var t=s(8439),e=s(758);function p(n){const a=Object.assign({p:"p",strong:"strong",ol:"ol",li:"li",h2:"h2",span:"span",h3:"h3",a:"a",ul:"ul"},(0,t.R)(),n.components);return e.createElement(e.Fragment,null,e.createElement(a.p,null,"在前端性能优化中存在一个老生常谈的问题：如何优化",e.createElement(a.strong,null,"高频率执行"),"的 JS 代码？例如："),"\n",e.createElement(a.ol,null,"\n",e.createElement(a.li,null,"我们为浏览器滚动 scroll 绑定了监听事件，当滚动到某位置之下后，会在浏览器右下方显示一个点击后能快速回到页面顶部的浮动按钮；而滚动回该位置之上时，浮动按钮消失。现在我们发现，用户每次使用滚轮滑动页面，都会触发很多次该事件，判断当前在该位置之上还是之下，这在一定程度上降低了前端的性能。"),"\n",e.createElement(a.li,null,"我们为网页添加了搜索功能，当用户输入搜索关键字后，会自动显示出搜索的结果。但是，用户每次更改输入都立即调用后端进行了搜索，彼时用户可能尚未输入完关键字，亦或是关键字输入错误需要修改。这样搜索出来的结果并非用户希望看到的，同时还降低了前端性能，浪费了大量的服务器资源。"),"\n"),"\n",e.createElement(a.p,null,"针对上述列举的问题，我们应该怎么做，才能在优化前端性能的同时不至于影响到用户的体验，便是本文探讨的内容。"),"\n",e.createElement(a.h2,null,"函数节流"),"\n",e.createElement(a.p,null,"函数节流（Throttle），指在触发事件后的一定时间内绑定的函数只能执行一次。"),"\n",e.createElement(a.p,null,"函数节流的实现思路比较简单，例如使用 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setTimeout</code>'}})," 方法实现：由于 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setTimeout</code>'}})," 方法的返回值是一个正整数，表示定时器的编号，所以可以利用闭包的方法维护一个定时器编号。每次触发事件时都通过定时器编号判断当前是否有尚未到期的定时器，如果有则结束，如果没有则启用一个定时器。定时器到期后调用绑定的需要节流的函数，并设置定时器编号为空，表示可以启用一个新的定时器。代码如下："),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">/**\n * 函数节流\n * 连续触发事件但是在 wait 毫秒中只执行一次函数\n * @param {Function} func 执行的函数\n * @param {Number} wait 函数节流等待的时间，单位为 ms\n * @returns 节流执行的函数\n */</span>\n<span class="token keyword">function</span> <span class="token function">throttle1</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> timer<span class="token punctuation">;</span> <span class="token comment">// 维护的定时器编号</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 返回节流执行的函数，可以绑定给事件</span>\n    <span class="token keyword">const</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span> <span class="token comment">// 执行函数的参数</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 当定时器不存在或已到期时</span>\n      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token comment">// 启用一个新的定时器</span>\n        timer <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 到期后设置定时器编号为空</span>\n        <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 到期后执行函数</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定时器等待 wait 毫秒后执行</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",e.createElement(a.p,null,e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setTimeout</code>'}})," 的方法，可以在触发事件后的 wait 毫秒自动后执行需要节流的函数。"),"\n",e.createElement(a.p,null,"需要特别留意的是上述代码有这样一个细节：",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setTimeout(() => { func.apply(this, args) }, wait)</code>'}}),"。"),"\n",e.createElement(a.p,null,"我们使用了箭头函数，使得 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setTimeout</code>'}})," 中方法内 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">this</code>'}})," 的作用于指向绑定此节流函数的对象，而非全局 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">window</code>'}})," 对象。"),"\n",e.createElement(a.p,null,"此外，如果不使用 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">apply()</code>'}})," 方法而是直接调用函数的话，节流执行函数内的 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">this</code>'}})," 对象仍指向的是全局的 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">window</code>'}})," 对象，而非我们期望的绑定此节流函数的对象，因此应使用 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">apply()</code>'}})," 传入 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">this</code>'}})," 上下文对象。"),"\n",e.createElement(a.p,null,"对于实现传入上下文对象，",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">call()</code>'}})," 方法的作用和 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">apply()</code>'}})," 相同，只是前者需要将传入的参数列举出来，而后者需要将传入的参数放在一个数组中。由于我们使用 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const args = arguments</code>'}})," 获取了函数传入的参数，而 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">args</code>'}})," 为一个数组，因此选择使用 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">apply()</code>'}})," 的方法。"),"\n",e.createElement(a.p,null,"假如不使用箭头函数，应该在 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setTimeout</code>'}})," 方法前获取 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">this</code>'}})," 上下文对象，再调用 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">apply()</code>'}})," 方法，如："),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">/**\n * 函数节流非箭头函数版本\n * 连续触发事件但是在 wait 毫秒中只执行一次函数\n * @param {Function} func 执行的函数\n * @param {Number} wait 函数节流等待的时间，单位为 ms\n * @returns 节流执行的函数\n */</span>\n<span class="token keyword">function</span> <span class="token function">throttle2</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> timer<span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>\n    <span class="token keyword">const</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 获取作用域上下文</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 使用 function () {} 的方式</span>\n        timer <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n        <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用绑定的上下文对象</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",e.createElement(a.p,null,"如果不喜欢 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setTimeout</code>'}})," 方法，也可以使用时间戳的方法实现函数节流：利用闭包的方法维护一个时间戳，每次触发事件时通过当前的时间戳和维护的时间戳之间的差值获取间隔的时间。若间隔时间大于预设的等待时间，则执行函数，并设置维护的时间戳为当前的时间戳。"),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">/**\n * 函数节流时间戳版本\n * 连续触发事件但是在 wait 毫秒中只执行一次函数\n * @param {Function} func 执行的函数\n * @param {Number} wait 函数节流等待的时间，单位为 ms\n * @returns 节流执行的函数\n */</span>\n<span class="token keyword">function</span> <span class="token function">throttle3</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> previous <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>\n    <span class="token keyword">const</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取当前的时间</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> previous <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// Date 对象在计算时会隐式转换为时间戳，当间隔时间大于等待时间时</span>\n      previous <span class="token operator">=</span> now<span class="token punctuation">;</span> <span class="token comment">// 设置维护的时间为当前的时间</span>\n      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行函数</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",e.createElement(a.p,null,"时间戳的方法不会在等待时间后自动执行需要节流的函数，而是在下一次触发事件后才执行。应根据具体需求在 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setTimeout</code>'}})," 和时间戳的方法之间进行选择。"),"\n",e.createElement(a.p,null,"特别的，我们可以设置当触发事件后立即执行需要节流的函数，再等待一定时间后才能再次执行此函数。基于 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">setTimeout</code>'}})," 的方法，改良代码如下："),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">/**\n * 函数节流 setTimeout 改良版本\n * 连续触发事件但是在 wait 毫秒中只执行一次函数\n * @param {Function} func 执行的函数\n * @param {Number} wait 函数节流等待的时间，单位为 ms\n * @param {Boolean} immediate 触发后立即执行函数\n * @returns 节流执行的函数\n */</span>\n<span class="token keyword">function</span> <span class="token function">throttle4</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> timer<span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 设置立即执行函数</span>\n        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          <span class="token comment">// 启用一个新的定时器</span>\n          timer <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 到期后设置定时器编号为空</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定时器等待 wait 毫秒后执行</span>\n        <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 立即执行函数</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          timer <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n          <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",e.createElement(a.h2,null,"函数防抖"),"\n",e.createElement(a.p,null,"函数防抖（Debounce），指在触发事件后的一定时间内绑定的函数只能执行一次，如果在这段时间内又触发了事件，则会重新计算时间。"),"\n",e.createElement(a.p,null,"从定义上来看，函数防抖像是函数节流的“强化版”：函数节流保证在一定时间内只执行一次事件绑定的函数，而函数防抖确保了事件在",e.createElement(a.strong,null,"一定时间内稳定不变"),"后才执行绑定的函数。"),"\n",e.createElement(a.p,null,"函数防抖的实现思路更加简单：同样适用闭包的方法维护一个定时器编号，每次触发事件时都通过此编号取消之前的定时器，并启用一个新的定时器。定时器到期后执行需要防抖的函数，并设置定时器编号为空。"),"\n",e.createElement(a.p,null,"特别的，我们也可以设置当触发事件后立即执行需要防抖的函数。触发事件时，若维护的定时器编号为空，表示可以立即执行函数。此时启用一个定时器，定时器到期后设置编号为空。当存在定时器编号时，表示仍在等待时间内，不会执行需要防抖的函数，此时我们清除前一个定时器，并启用一个新的定时器。"),"\n",e.createElement(a.p,null,"代码如下："),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">/**\n * 函数防抖\n * 触发事件后在 wait 毫秒内函数只执行一次；如果在 wait 毫秒内又触发了事件，则会重新计算函数执行时间\n * @param {Function} func 需要防抖的函数\n * @param {Number} wait 防抖的等待时间，单位为 ms\n * @param {Boolean} immediate 触发事件后立即执行函数\n * @returns 防抖执行的函数\n */</span>\n<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> immediate <span class="token operator">=</span> <span class="token boolean">false</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> timer<span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>\n\n    timer <span class="token operator">&amp;&amp;</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果定时器编号不为空，则清除定时器。此处只是清除定时器，并未清除定时器编号</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 设置立即执行函数</span>\n      <span class="token operator">!</span>timer <span class="token operator">&amp;&amp;</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果定时器编号不为空，即在等待时间内，不执行函数；若为空，则执行函数</span>\n      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token comment">// 启用新的定时器</span>\n        timer <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span> <span class="token comment">// 定时器到期后清空定时器编号</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定时器等待 wait 毫秒后执行</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 不立即执行函数</span>\n      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token comment">// 启用新的定时器</span>\n        <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定时器到期后执行函数</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定时器等待 wait 毫秒后执行</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",e.createElement(a.h2,null,"在 Nuxt.js 中引入函数节流和防抖"),"\n",e.createElement(a.p,null,"在项目的 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">plugins</code>'}})," 目录下创建一个新的文件，例如 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">main.js</code>'}}),"。将函数节流和防抖添加为 Vue 的实例方法。如："),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// plugins/main.js</span>\n<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> main <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">install</span><span class="token punctuation">(</span><span class="token parameter">Vue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 注册到 Vue.prototype.$Main 中</span>\n    <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$Main <span class="token operator">=</span> <span class="token punctuation">{</span>\n      throttle<span class="token punctuation">,</span>\n      debounce<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nVue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>'}}),"\n",e.createElement(a.p,null,"接下来在 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">nuxt.config.js</code>'}})," 中引入："),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"~/plugins/main.js"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>'}}),"\n",e.createElement(a.p,null,"就可以在组件中通过 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">this.$Main.throttle()</code>'}})," 调用函数了。其中 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">this</code>'}})," 指向了全局的 Vue 对象。"),"\n",e.createElement(a.h2,null,"简单的使用示例"),"\n",e.createElement(a.h3,null,"浏览器滚动事件"),"\n",e.createElement(a.p,null,"对于本博客开头提出的第一种情况，我们可以使用函数节流的方案优化前端性能。"),"\n",e.createElement(a.p,null,"为什么不用函数防抖？假如用户一直在滚动浏览器，那么直到用户停止滚动前，都不会执行函数判断当前滚动位置。而使用函数节流，无论用户是否一直在滚动浏览器，都会在一定时间后再次执行函数判断当前滚动位置。"),"\n",e.createElement(a.p,null,"基于 Vuetify UI 组件库编写 Vue 代码如下："),"\n",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="vue"><pre class="language-vue"><code class="language-vue">&lt;template&gt;\n  &lt;v-fab-transition&gt;\n    &lt;!-- 当窗口滚动值大于 300 时显示按钮 --&gt;\n    &lt;v-btn\n      v-show=&quot;scrollVal &gt; 300&quot;\n      fixed\n      fab\n      dark\n      bottom\n      right\n      color=&quot;white&quot;\n      elevation=&quot;2&quot;\n      class=&quot;mb-12&quot;\n      @click=&quot;backToTop&quot;\n    &gt;\n      &lt;v-icon color=&quot;primary&quot;&gt;mdi-arrow-up&lt;/v-icon&gt;\n    &lt;/v-btn&gt;\n  &lt;/v-fab-transition&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  data: () =&gt; ({\n    // 当前的窗口滚动值\n    scrollVal: 0,\n  }),\n  mounted() {\n    // 每 500 毫秒获取当前的 scrollVal 值\n    const throttleOnScroll = this.$Main.throttle(this.onScroll, 500);\n    // 为 window 添加滚动事件\n    window.addEventListener(&quot;scroll&quot;, throttleOnScroll);\n  },\n  methods: {\n    // 获取 window.pageYOffset 值并赋值给 scrollVal\n    onScroll() {\n      this.scrollVal = window.pageYOffset;\n    },\n    // 回到顶端\n    backToTop() {\n      window.scroll({\n        top: 0,\n        left: 0,\n        behavior: &quot;smooth&quot;,\n      });\n    },\n  },\n};\n&lt;/script&gt;</code></pre></div>'}}),"\n",e.createElement(a.p,null,e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">window.pageYOffset</code>'}})," 是 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">window.scrollY</code>'}})," 的别名，前者的浏览器兼容性较好，调用时将返回文档在垂直方向已滚动的像素值。"),"\n",e.createElement(a.p,null,e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">onScroll()</code>'}})," 方法可以获取当前文档在垂直方向已滚动的像素值并赋值给 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">scrollVal</code>'}}),"，而浮动按钮根据此值判断是否显示。上述代码设定当该值大于 300 时显示浮动按钮。"),"\n",e.createElement(a.p,null,"上述代码将 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">onScroll()</code>'}})," 方法封装成了一个等待时间为 500 毫秒的节流函数 ",e.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">throttleOnScroll()</code>'}}),"，并将该节流函数绑定给浏览器滚动事件。"),"\n",e.createElement(a.p,null,"当用户滚动浏览器时，每隔 500 毫秒会获取当前已滚动的像素值，浮动按钮再根据此值判断是否显示，性能优化完成！"),"\n",e.createElement(a.h2,null,"Easy ride"),"\n",e.createElement(a.p,null,"不想自己手撸函数节流和防抖？"),"\n",e.createElement(a.p,null,"那就用封装好的吧：",e.createElement(a.a,{href:"https://lodash.com/"},"Lodash"),"，你值得拥有。"),"\n",e.createElement(a.h2,null,"参考资料"),"\n",e.createElement(a.ul,null,"\n",e.createElement(a.li,null,e.createElement(a.a,{href:"https://juejin.cn/post/6914591853882900488"},"终于搞懂：防抖和节流"),", 2021-01-06"),"\n",e.createElement(a.li,null,e.createElement(a.a,{href:"https://segmentfault.com/a/1190000018445196"},"彻底弄懂函数防抖和函数节流"),", 2019-03-09"),"\n",e.createElement(a.li,null,e.createElement(a.a,{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5"},"什么是防抖和节流？有什么区别？如何实现"),", 2019-01-23"),"\n",e.createElement(a.li,null,e.createElement(a.a,{href:"https://www.jianshu.com/p/f9f6b637fd6c"},"浅析函数防抖与函数节流"),", 2018-08-12"),"\n"))}var o=function(n){void 0===n&&(n={});const{wrapper:a}=Object.assign({},(0,t.R)(),n.components);return a?e.createElement(a,n,e.createElement(p,n)):p(n)},c=s(6948),l=s(3021),u=s.n(l),r=s(2182),i=s(4447),k=s(9557),m=s(4878),d=s(7149);const g={a:n=>{let{href:a="",children:s}=n;const t=!(null!=a&&a.startsWith("#")),p=t?a:`#${encodeURIComponent(a.slice(1))}`;return e.createElement("a",{href:p,target:t?"_blank":void 0,rel:"noreferrer"},s)},img:n=>{const{alt:a="The author is too lazy to give an alt",src:s,...t}=n;return e.createElement("a",{href:s,"data-fancybox":"gallery","data-caption":a},e.createElement("img",Object.assign({src:s,alt:a},t)))},Card:i.A,Link:r.Link},h=n=>{let{children:a,data:s}=n;const{mdx:{fields:{isDraft:p},frontmatter:{title:o,date:l,updated:r,categories:i,tags:m,timeliness:h}}}=s,y=e.useRef(null),f=u()(l),w=r?u()(r):f,E=u()().diff(w,"days");return e.useEffect(()=>{var n;const a=null===(n=y.current)||void 0===n?void 0:n.querySelectorAll("a.gatsby-resp-image-link");return null==a||a.forEach(n=>{const a=n.children.item(1);n.setAttribute("data-fancybox","gallery"),n.setAttribute("data-caption",a.alt)}),c.lX.bind("[data-fancybox]"),()=>c.lX.unbind("[data-fancybox]")},[]),e.createElement("div",{className:"mx-auto flex max-w-xl flex-col gap-y-12"},e.createElement("div",{className:"flex flex-col gap-4"},(null==i?void 0:i.length)&&e.createElement(k.A,{name:i[0],className:"item-selectable"}),e.createElement("h1",{className:"text-3xl font-bold"},o),e.createElement("div",{className:"item-secondary flex flex-col gap-2 lg:flex-row"},l&&e.createElement("span",{title:`首次发布于：${f.toString()}\n最后更新于：${w.toString()}`},f.format("MM 月 DD 日 YYYY 年")),(null==m?void 0:m.length)&&e.createElement("div",{className:"flex flex-1 flex-wrap gap-2 lg:before:content-['•']"},m.map(n=>e.createElement(d.A,{key:n,name:n,className:"item-secondary item-selectable"}))))),e.createElement("article",{ref:y,className:"heti post-entry"},p&&e.createElement("blockquote",{className:"!border-red-400"},"这是一篇",e.createElement("strong",null,"未正式发布"),"的博客，内容可能尚未撰写完全或存在一些纰漏，建议您仔细评估信息的有效性。"),!1!==h&&E>365&&e.createElement("blockquote",{className:"!border-orange-400"},"这是一篇",e.createElement("strong",null,"最后更新于 ",E," 天前"),"的博客，内容可能随着时间的推移而变得不再适用，建议您仔细评估信息的有效性。"),e.createElement(t.x,{components:g},a)))},y=n=>{let{data:a}=n;return e.createElement(m.A,{title:String(a.mdx.frontmatter.title)})};function f(n){return e.createElement(h,n,e.createElement(o,n))}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-blog-posts-js-debounce-throttle-mdx-bbbf1fdfb5a53e4195f7.js.map