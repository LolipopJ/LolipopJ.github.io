"use strict";(self.webpackChunkhomepage=self.webpackChunkhomepage||[]).push([[4426],{3282:function(n,a,e){e.r(a),e.d(a,{Head:function(){return f},default:function(){return E}});var t=e(8453),s=e(6540);function o(n){const a=Object.assign({p:"p",span:"span",strong:"strong",h2:"h2",ul:"ul",li:"li",a:"a",blockquote:"blockquote",em:"em",h3:"h3"},(0,t.R)(),n.components);return s.createElement(s.Fragment,null,s.createElement(a.p,null,"在 ES6 规范出现之前，使用 JavaScript 声明变量只有 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">var</code>'}}),", ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">function</code>'}})," 以及隐式声明三种方式。"),"\n",s.createElement(a.p,null,"按照一般编程的思维，我们会通过“先声明，后调用”的方式去使用变量，例如："),"\n",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></code></pre></div>'}}),"\n",s.createElement(a.p,null,"但假如反过来，我们“先调用，后声明”，会发生什么呢？"),"\n",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError: b is not defined</span></code></pre></div>'}}),"\n",s.createElement(a.p,null,"如上所示，在声明变量 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">a</code>'}})," 之前尝试将它的值打印出来，控制台输出的结果是 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">undefined</code>'}}),"，而不是预期中的报错 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Uncaught ReferenceError: a is not defined</code>'}}),"。这就是",s.createElement(a.strong,null,"变量提升"),"。"),"\n",s.createElement(a.p,null,"而对于函数的声明与使用，也出现了相似的情况："),"\n",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello there!</span>\n\n<span class="token keyword">function</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hello there!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",s.createElement(a.p,null,"在声明函数之前，我们已经可以调用函数方法并正确输出。这便是",s.createElement(a.strong,null,"函数提升"),"。"),"\n",s.createElement(a.p,null,"在 JavaScript 中奇怪的一点是，我们可以在声明变量（使用 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">var</code>'}}),"）和声明函数之前使用它们，就好像变量和函数的声明被提升到了代码的顶部一样："),"\n",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>\n\n<span class="token comment">// 好像等于下面的代码</span>\n<span class="token keyword">var</span> a<span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\na <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span></code></pre></div>'}}),"\n",s.createElement(a.p,null,"实际上，JavaScript 并不会移动代码，变量提升和函数提升并不是真正意义上的“提升”，而是解释执行 JavaScript 代码过程所带来的“特性”。"),"\n",s.createElement(a.h2,null,"发生了什么"),"\n",s.createElement(a.p,null,"以现在最主流的 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">V8</code>'}})," 引擎为例，其解释执行 JavaScript 代码的过程大致分为生成抽象语法树（AST），生成字节码和生成机器码三个阶段。"),"\n",s.createElement(a.p,null,"在生成抽象语法树阶段，又分为了词法分析和语法分析两个阶段。其中，在词法分析阶段，JavaScript 会检测到当前",s.createElement(a.strong,null,"作用域"),"使用到的所有变量和函数声明，并将这些变量和函数声明添加到一个名为",s.createElement(a.strong,null,"词法环境"),"（Lexical Environment）的内存空间当中。"),"\n",s.createElement(a.p,null,"在词法分析阶段，对于变量声明和函数声明，词法环境的处理是不一样的："),"\n",s.createElement(a.ul,null,"\n",s.createElement(a.li,null,"对于变量声明如 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">var a = 3</code>'}}),"，会为变量分配内存并初始化为 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">undefined</code>'}}),"，赋值语句在生成机器码阶段真正执行代码的时候才进行。"),"\n",s.createElement(a.li,null,"对于函数声明如 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:"<code class=\"language-text\">function sayHello() { console.log('Hello there!') }</code>"}}),"，会在内存里创建函数对象，并且直接初始化为该函数对象。"),"\n"),"\n",s.createElement(a.p,null,"因此，对于变量声明，在真正执行到赋值语句之前，我们就已经可以使用此变量，但是初值为 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">undefined</code>'}}),"；而对于函数声明，在执行到函数声明之前，函数对象就已经存在在内存当中，并可以直接调用了。"),"\n",s.createElement(a.p,null,"应当注意的是，函数声明的处理优先级要高于变量声明（意味着函数会“提升”到更靠前的位置）："),"\n",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\nfoo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token comment">// 相当于下面的代码</span>\n<span class="token keyword">var</span> foo<span class="token punctuation">;</span>\n<span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\nfoo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 依次打印出：</span>\n<span class="token comment">// function foo() {}</span>\n<span class="token comment">// 3</span></code></pre></div>'}}),"\n",s.createElement(a.p,null,"另外，变量提升和函数提升都是将声明“提升”到当前",s.createElement(a.strong,null,"作用域"),"的顶端："),"\n",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">hoist</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  foo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">hoist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 相当于下面的代码</span>\n<span class="token keyword">var</span> hoist<span class="token punctuation">;</span>\n<span class="token keyword">var</span> foo<span class="token punctuation">;</span>\n\n<span class="token function-variable function">hoist</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> foo<span class="token punctuation">;</span>\n  <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  foo <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nfoo <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>\n\n<span class="token function">hoist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 依次打印出：</span>\n<span class="token comment">// function foo() {}</span>\n<span class="token comment">// 3</span>\n<span class="token comment">// 5</span></code></pre></div>'}}),"\n",s.createElement(a.p,null,s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">hoist()</code>'}})," 方法中执行的 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">console.log(foo)</code>'}})," 优先从当前作用域中寻找变量 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">foo</code>'}}),"，如果找不到才在父级作用域寻找。"),"\n",s.createElement(a.h2,null,"匿名函数声明"),"\n",s.createElement(a.p,null,"如果将函数赋值给一个变量会怎样："),"\n",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: sayHi is not a function</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sayHi<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>\n<span class="token keyword">var</span> <span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hi there!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hi there!</span></code></pre></div>'}}),"\n",s.createElement(a.p,null,"使用匿名函数声明时，",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">sayHi</code>'}})," 发生变量提升，但赋值为 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">undefined</code>'}}),"，因此执行 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">sayHi()</code>'}})," 时会报错 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Uncaught TypeError: sayHi is not a function</code>'}}),"。随后执行完赋值语句后，才成为一个可以执行的函数变量。"),"\n",s.createElement(a.h2,null,"防止变量提升"),"\n",s.createElement(a.p,null,"在 ES6 中，提供了两个声明变量的新的命令，即现在我们最常用的 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 和 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}}),"。使用 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 声明的变量可以修改，而使用 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 声明的变量不可更改。使用 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 声明必须指定初始值。"),"\n",s.createElement(a.p,null,"使用 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">var</code>'}}),", ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 和 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 声明的变量都会被“提升”，不同的是："),"\n",s.createElement(a.ul,null,"\n",s.createElement(a.li,null,s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">var</code>'}})," 命令在变量的定义被执行之前就初始化变量，并拥有一个默认的 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">undefined</code>'}})," 值。"),"\n",s.createElement(a.li,null,s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 与 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 命令会形成",s.createElement(a.strong,null,"暂时性死区"),"，在变量的定义被执行之前都",s.createElement(a.strong,null,"不会初始化变量"),"，避免在声明语句之前的不正确调用。如果定义时没有给定值的话，",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 声明的变量会赋值为 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">undefined</code>'}}),"，而 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 声明的变量会报错。"),"\n"),"\n",s.createElement(a.p,null,"关于暂时性死区的概念，援引阮一峰老师在 ",s.createElement(a.a,{href:"https://es6.ruanyifeng.com/#docs/let"},"ES6 入门书"),"中的话："),"\n",s.createElement(a.blockquote,null,"\n",s.createElement(a.p,null,"ES6 明确规定，如果区块中存在 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 和 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n总之，在代码块内，使用 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone）。"),"\n"),"\n",s.createElement(a.p,null,"下面是一个使用 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 声明函数的例子："),"\n",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError: Cannot access \'test\' before initialization</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError: Cannot access \'test\' before initialization</span>\n<span class="token keyword">const</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// test</span></code></pre></div>'}}),"\n",s.createElement(a.p,null,"在这里，我们使用了 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 命令声明函数，只要一进入当前作用域，所要使用的 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">test</code>'}})," 变量就已经存在了，但是不可获取，如果获取则会抛出特别的错误 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:"<code class=\"language-text\">Uncaught ReferenceError: Cannot access 'test' before initialization</code>"}}),"（一般情况下，获取未声明的变量抛出的错误为 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Uncaught ReferenceError: test is not defined</code>'}}),"）。只有等到声明变量的那一行代码出现，才可以获取和使用该变量。使用 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 命令也有同样的效果。"),"\n",s.createElement(a.p,null,s.createElement(a.em,null,s.createElement(a.a,{href:"https://google.github.io/styleguide/jsguide.html#features-use-const-and-let"},"Google JavaScript Style Guide"))," 建议使用 ES6 规范的 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 和 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 命令声明变量，舍弃容易造成错误的 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">var</code>'}})," 命令。"),"\n",s.createElement(a.h2,null,"为什么有变量提升和函数提升"),"\n",s.createElement(a.p,null,"布兰登·艾克（Brendan Eich）是 JavaScript 的主要创造者与架构师，关于“为什么要变量提升”这个问题，他给出了这样的回答："),"\n",s.createElement(a.blockquote,null,"\n",s.createElement(a.p,null,'Q: So what is one of the main (if not the main) reasons of variables "hoisting"? / 那么，变量“提升”的主要（或者并非主要）的原因之一是什么呢？\nBrendan Eich: An "abstraction leak" from the first JavaScript VM. Compiler indexes vars to stack slots, binds names to slots on entry. / 这源于第一批 JavaScript 虚拟机的“抽象泄漏”问题。编译器在入口处将变量索引到了堆栈插槽，并把变量名绑定给了插槽。'),"\n"),"\n",s.createElement(a.p,null,s.createElement(a.strong,null,"抽象泄漏"),"是一个计算机术语，指“本应隐藏实现细节的抽象化不可避免地暴露出底层细节与局限性”。这是一个非常有意思的概念，以 TCP 协议举例："),"\n",s.createElement(a.blockquote,null,"\n",s.createElement(a.p,null,"当我说 TCP 协议可以保证消息一定能够到达，事实上并非如此。如果你的宠物蛇把网线给咬坏了，那即便是 TCP 协议也无法传输数据；如果你和网络管理员闹了矛盾，他将你的网口接到了一台负载很高的交换机上，那即便你的数据包可以传输，速度也会奇慢无比。\n这就是我所说的“抽象泄漏”。TCP 协议试图提供一个完整的抽象，将底层不可靠的数据传输包装起来，但是，底层的传输有时也会发生问题，即便是 TCP 协议也无法解决，这时你会发现，它也不是万能的。TCP 协议就是“抽象泄漏定律”的示例之一，其实，几乎所有的抽象都是泄漏的。"),"\n"),"\n",s.createElement(a.p,null,"言归正传，正是由于第一批 JavaScript 虚拟机编译器上代码的设计失误，导致变量在声明之前就被赋予了 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">undefined</code>'}})," 的初始值，而又由于这个失误产生的影响（无论好坏）过于广泛，因此在现在的 JavaScript 编译器中仍保留了变量提升的“特性”。"),"\n",s.createElement(a.p,null,"至于“为什么要函数提升”，有人提出可能是为了解决函数相互递归调用的问题，布兰登·艾克给予了肯定并补充道："),"\n",s.createElement(a.blockquote,null,"\n",s.createElement(a.p,null,"Brendan Eich: Yes, function declaration hoisting is for mutual recursion & generally to avoid painful bottom-up ML-like order. / 是的，函数提升是为了解决函数相互递归调用的问题，并在总体上避免了像 ML 语言那样痛苦地自下而上调用的问题。"),"\n"),"\n",s.createElement(a.p,null,s.createElement(a.strong,null,"函数相互递归调用"),"，可以理解为 A 函数内会调用到 B 函数，而 B 函数也会调用到 A 函数。ML 语言是 20 世纪 70 年代早期开发出来的通用的函数式编程语言。"),"\n",s.createElement(a.p,null,"举一个经典的例子："),"\n",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isEven</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token function">isOdd</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isEven</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n\n<span class="token keyword">function</span> <span class="token function">isOdd</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token function">isEven</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",s.createElement(a.p,null,"如果没有函数提升，在调用 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">isEven</code>'}})," 方法时，由于 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">isOdd</code>'}})," 方法还未声明，那么理论上执行就会出现错误，反之亦然。通过函数提升，",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">isEven</code>'}})," 和 ",s.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">isOdd</code>'}})," 方法之间的相互递归调用也就可以实现了。"),"\n",s.createElement(a.h2,null,"参考资料"),"\n",s.createElement(a.p,null,"对变量提升和函数提升的进一步学习探讨可以参考这篇博文",s.createElement(a.a,{href:"https://blog.techbridge.cc/2018/11/10/javascript-hoisting/"},"《我知道你懂 hoisting，可是你了解到多深？》"),"，非常之棒！"),"\n",s.createElement(a.h3,null,"技术博客"),"\n",s.createElement(a.ul,null,"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"https://chinese.freecodecamp.org/news/javascript-var-let-and-const"},"JavaScript 中的 Var，Let 和 Const 有什么区别"),", 2020-12-08"),"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"https://juejin.cn/post/6844903895341219854"},"从本质上理解 JavaScript 中的变量提升"),", 2019-07-23"),"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"https://limeii.github.io/2019/05/js-lexical-environment/"},"JavaScript：深入理解 JavaScript-词法环境"),", 2019-05-06"),"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"https://blog.csdn.net/weixin_38080573/article/details/79372448"},"变量声明系列之 ES5(变量提升)"),", 2018-02-25"),"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"https://www.cnblogs.com/liuhe688/p/5891273.html"},"JavaScript: 变量提升和函数提升"),", 2016-10-18"),"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"http://shzhangji.com/cnblogs/2013/12/17/the-law-of-leaky-abstractions/"},"抽象泄漏定律"),", 2013-12-17, 英文",s.createElement(a.a,{href:"https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/"},"原文链接")),"\n"),"\n",s.createElement(a.h3,null,"其它资料"),"\n",s.createElement(a.ul,null,"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting"},"Hoisting（变量提升）- MDN")),"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"https://google.github.io/styleguide/jsguide.html"},"Google JavaScript Style Guide")),"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"https://es6.ruanyifeng.com"},"let 和 const 命令 - 《ECMAScript 6 入门》")),"\n",s.createElement(a.li,null,s.createElement(a.a,{href:"https://en.wikipedia.org/wiki/Leaky_abstraction"},"Leaky abstraction - Wikipedia")),"\n"),"\n",s.createElement(a.h2,null,"关于抽象泄漏的补充"),"\n",s.createElement(a.p,null,"艾林·约耳·斯波尔斯基（Avram Joel Spolsky）是程序员必备的问答网站 Stack Overflow 的创始人之一，于 2002 年 11 月 11 日在博文 ",s.createElement(a.a,{href:"https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/"},s.createElement(a.em,null,"The Law of Leaky Abstractions"))," 中对抽象泄漏定律做了非常详尽的描述，其中一些看法让我再赞同不过了，遂记录在这里（中文翻译来自",s.createElement(a.a,{href:"http://shzhangji.com/cnblogs/2013/12/17/the-law-of-leaky-abstractions/"},"此博客"),"）："),"\n",s.createElement(a.blockquote,null,"\n",s.createElement(a.p,null,"......\nOne reason the law of leaky abstractions is problematic is that it means that abstractions do not really simplify our lives as much as they were meant to. When I’m training someone to be a C++ programmer, it would be nice if I never had to teach them about char*’s and pointer arithmetic. It would be nice if I could go straight to STL strings. But one day they’ll write the code “foo” + “bar”, and truly bizarre things will happen, and then I’ll have to stop and teach them all about char*’s anyway. Or one day they’ll be trying to call a Windows API function that is documented as having an OUT LPTSTR argument and they won’t be able to understand how to call it until they learn about char*’s, and pointers, and Unicode, and wchar_t’s, and the TCHAR header files, and all that stuff that leaks up.\n抽象泄漏引发的麻烦之一是，它并没有完全简化我们的工作。当我指导别人学习 C++ 时，我当然希望可以跳过 char * 和指针运算，直接讲解 STL 字符串类库的使用。但是，当某一天他写出了 “foo” + “bar” 这样的代码，并询问我为什么编译错误时，我还是需要告诉他 char * 的存在。或者说，当他需要调用一个 Windows API，需要指定 OUT LPTSTR 参数，这时他就必须学习 char *、指针、Unicode、wchar_t、TCHAR 头文件等一系列知识，这些都是抽象泄漏。\n......\nIn teaching someone about ASP.NET programming, it would be nice if I could just teach them that they can double-click on things and then write code that runs on the server when the user clicks on those things. Indeed ASP.NET abstracts away the difference between writing the HTML code to handle clicking on a hyperlink (<a>) and the code to handle clicking on a button. Problem: the ASP.NET designers needed to hide the fact that in HTML, there’s no way to submit a form from a hyperlink. They do this by generating a few lines of JavaScript and attaching an onclick handler to the hyperlink. The abstraction leaks, though. If the end-user has JavaScript disabled, the ASP.NET application doesn’t work correctly, and if the programmer doesn’t understand what ASP.NET was abstracting away, they simply won’t have any clue what is wrong.\n在指导 ASP.NET 编程时，我希望可以直接告诉大家双击页面上的控件，在弹出的代码框中输入点击响应事件。的确，ASP.NET 将处理点击的 HTML 代码抽象掉了，但问题在于，ASP.NET 的设计者需要动用 JavaScript 来模拟表单的提交，因为 HTML 中的 <a> 标签是没有这一功能的。这样一来，如果终端用户将 JavaScript 禁止了，这个程序将无法运行。初学者会不知所措，直至他了解 ASP.NET 的运作方式，了解它究竟将什么样的工作封装起来了，才能进一步排查。\nThe law of leaky abstractions means that whenever somebody comes up with a wizzy new code-generation tool that is supposed to make us all ever-so-efficient, you hear a lot of people saying “learn how to do it manually first, then use the wizzy tool to save time.” Code generation tools which pretend to abstract out something, like all abstractions, leak, and the only way to deal with the leaks competently is to learn about how the abstractions work and what they are abstracting. So the abstractions save us time working, but they don’t save us time learning.\n由于抽象定律的存在，每当有人说自己发现了一款新的代码生成工具，能够大大提高我们的编程效率时，你会听很多人说“先学习手工编写，再去用工具生成”。代码生成工具是一种抽象，同样也会泄漏，唯一的解决方法是学习它的实现原理，即它抽象了什么。所以说抽象只是用于提高我们的工作效率的，而不会节省我们的学习时间。\nAnd all this means that paradoxically, even as we have higher and higher level programming tools with better and better abstractions, becoming a proficient programmer is getting harder and harder.\n这就形成了一个悖论：当我们拥有越来越高级的开发工具，越来越好的“抽象”，要成为一个高水平的程序员反而越来越困难了。\n......\nTen years ago, we might have imagined that new programming paradigms would have made programming easier by now. Indeed, the abstractions we’ve created over the years do allow us to deal with new orders of complexity in software development that we didn’t have to deal with ten or fifteen years ago, like GUI programming and network programming. And while these great tools, like modern OO forms-based languages, let us get a lot of work done incredibly quickly, suddenly one day we need to figure out a problem where the abstraction leaked, and it takes 2 weeks. And when you need to hire a programmer to do mostly VB programming, it’s not good enough to hire a VB programmer, because they will get completely stuck in tar every time the VB abstraction leaks.\n十年前，我们会想象未来能够出现各种新式的编程范型，简化我们的工作。的确，这些年我们创造的各类抽象使得开发复杂的大型软件变得比十五年前要简单得多，就像 GUI 和网络编程。现代的面向对象编程语言让我们的工作变得高效快速。但突然有一天，这种抽象泄漏出一个问题，解决它需要耗费两星期。如果你需要招录一个 VB 程序员，那不是一个好主意，因为当他碰到 VB 语言泄漏的问题时，他会变得寸步难行。\nThe Law of Leaky Abstractions is dragging us down.\n抽象泄漏定律正在阻碍我们前进。"),"\n"))}var l=function(n){void 0===n&&(n={});const{wrapper:a}=Object.assign({},(0,t.R)(),n.components);return a?s.createElement(a,n,s.createElement(o,n)):o(n)},c=e(197),p=e(4353),u=e.n(p),r=e(4810),i=e(6947),d=e(4017),m=e(1042),k=e(1038);const g={a:n=>{let{href:a="",children:e}=n;const t=!(null!=a&&a.startsWith("#")),o=t?a:`#${encodeURIComponent(a.slice(1))}`;return s.createElement("a",{href:o,target:t?"_blank":void 0,rel:"noreferrer"},e)},img:n=>{const{alt:a="The author is too lazy to give an alt",src:e,...t}=n;return s.createElement("a",{href:e,"data-fancybox":"gallery","data-caption":a},s.createElement("img",Object.assign({src:e,alt:a},t)))},Card:i.A,Link:r.N_},h=n=>{let{children:a,pageContext:e}=n;const{frontmatter:{title:o,date:l,updated:p,categories:r,tags:i,timeliness:m=!0}}=e,h=s.useRef(null),f=u()(l),E=p?u()(p):f,y=u()().diff(E,"days");return s.useEffect((()=>{var n;const a=null===(n=h.current)||void 0===n?void 0:n.querySelectorAll("a.gatsby-resp-image-link");return null==a||a.forEach((n=>{const a=n.children.item(1);n.setAttribute("data-fancybox","gallery"),n.setAttribute("data-caption",a.alt)})),c.lX.bind("[data-fancybox]"),()=>c.lX.unbind("[data-fancybox]")}),[]),s.createElement("div",{className:"mx-auto flex max-w-xl flex-col gap-y-12"},s.createElement("div",{className:"flex flex-col gap-4"},(null==r?void 0:r.length)&&s.createElement(d.A,{name:r[0],className:"item-selectable"}),s.createElement("h1",{className:"text-3xl font-bold"},o),s.createElement("div",{className:"item-secondary flex gap-2"},l&&s.createElement("span",{title:`首次发布于：${f.toString()}\n最后更新于：${E.toString()}`},f.format("MM 月 DD 日 YYYY 年")),(null==i?void 0:i.length)&&s.createElement("div",{className:"flex flex-1 flex-wrap gap-2 before:content-['•']"},i.map((n=>s.createElement(k.A,{key:n,name:n,className:"item-secondary item-selectable"})))))),s.createElement("article",{ref:h,className:"heti post-entry"},m&&y>365&&s.createElement("blockquote",{className:"border-l-4 border-orange-400"},"这是一篇",s.createElement("strong",null,"最后更新于 ",y," 天前"),"的博客，内容可能随着时间的推移而变得不再适用，建议您仔细评估信息的有效性。"),s.createElement(t.x,{components:g},a)))},f=n=>{let{pageContext:a}=n;return s.createElement(m.A,{title:a.frontmatter.title})};function E(n){return s.createElement(h,n,s.createElement(l,n))}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-blog-posts-js-hoisting-mdx-697771750d4de63dd22a.js.map