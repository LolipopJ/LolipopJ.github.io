"use strict";(self.webpackChunkhomepage=self.webpackChunkhomepage||[]).push([[1641],{7532:function(e,a,n){n.r(a),n.d(a,{Head:function(){return b},default:function(){return E}});var s=n(8453),t=n(6540);function l(e){const a=Object.assign({p:"p",a:"a",h2:"h2",span:"span",blockquote:"blockquote",h3:"h3"},(0,s.R)(),e.components),{Link:n}=a;return n||function(e,a){throw new Error("Expected "+(a?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Link",!0),t.createElement(t.Fragment,null,t.createElement(a.p,null,"本文适用于 C++ 版本 gRPC 的离线编译安装，但对于",t.createElement(a.a,{href:"#%E4%B8%8B%E8%BD%BD-gRPC"},"下载 gRPC")," 步骤强烈建议使用 git 进行。"),"\n",t.createElement(a.p,null,"如果在能直接连接外网的机器上编译，可直接按照 ",t.createElement(a.a,{href:"https://github.com/grpc/grpc"},"gRPC 官网文档"),"的指引快速执行编译操作。"),"\n",t.createElement(a.h2,null,"安装基本依赖"),"\n",t.createElement(a.p,null,"确保机器上包括这些基本依赖：",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">autoconf</code>'}}),", ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">libtool</code>'}}),", ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">pkg-config</code>'}})," 与 C++ 编译环境。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 检查是否有 autoconf</span>\n<span class="token function">which</span> autoconf\n\n<span class="token comment"># 如果没有，则安装</span>\n<span class="token comment"># CentOS</span>\nyum <span class="token function">install</span> autoconf\n<span class="token comment"># Ubuntu</span>\n<span class="token function">apt-get</span> <span class="token function">install</span> autoconf</code></pre></div>'}}),"\n",t.createElement(a.p,null,"gRPC 的编译需要 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gcc</code>'}})," 版本在 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">4.9</code>'}})," 及以上。假如版本低于此，应当在 Docker 容器中安装较新版本的 GCC 再执行编译操作。"),"\n",t.createElement(a.p,null,"我使用 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gcc 4.9.4</code>'}})," 成功编译 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gRPC 1.28.x</code>'}}),"，另外",t.createElement(a.a,{href:"https://github.com/grpc/grpc/issues/24932#issuecomment-754344093"},"有人测试"),"在 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">4.9.2</code>'}}),", ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">5.3.1</code>'}})," 以及 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">7.3.1</code>'}})," 版本编译成功；而我使用撰写此文时使用最新版本 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">10.3.0</code>'}})," 编译报错，请读者加以选择。"),"\n",t.createElement(a.p,null,"更新 GCC 的方法可以参考我的",t.createElement(n,{to:"/posts/linux-docker-gcc-update"},"这一篇博客"),"。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 查看 gcc 版本</span>\ngcc <span class="token parameter variable">-v</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"如果机器上没有 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gcc</code>'}})," 或 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">g++</code>'}})," 等，可以安装 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Development Tools</code>'}})," 或 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">build-essential</code>'}})," 软件包。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># CentOS</span>\nyum groupinstall <span class="token string">"Development Tools"</span>\n<span class="token comment"># Ubuntu</span>\n<span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> build-essential</code></pre></div>'}}),"\n",t.createElement(a.h2,null,"安装 CMake"),"\n",t.createElement(a.blockquote,null,"\n",t.createElement(a.p,null,t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">make</code>'}})," 是 gRPC 以前使用的构建命令，但是官方文档不再建议使用它。应使用 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">bazel</code>'}})," 或 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">cmake</code>'}})," 代替。此处我们选择使用 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">cmake</code>'}})," 执行编译。"),"\n"),"\n",t.createElement(a.p,null,"执行下述命令，如果没有找到命令则需要安装 CMake。目前编译 gRPC 需要的 CMake 最低版本为 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">3.5.1</code>'}}),"，建议使用的 CMake 版本为 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">3.13</code>'}})," 及以上。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 查看当前 CMake 版本</span>\ncmake <span class="token parameter variable">--version</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"在 ",t.createElement(a.a,{href:"https://cmake.org/download/"},"CMake 官网"),"下载需要版本的 CMake 源码或二进制文件。"),"\n",t.createElement(a.p,null,"例如下载适用于 x86_64 的 Linux 系统的二进制文件，可以选择下载 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">cmake-3.20.1-linux-x86_64.tar.gz</code>'}}),"，其中 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">3.20.1</code>'}})," 为版本号。"),"\n",t.createElement(a.p,null,"解压，可以将 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">/path/to/cmake-3.20.1-linux-x86_64/bin/</code>'}})," 目录下的二进制文件复制粘贴到 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">/usr/bin/</code>'}})," 目录下；或是为它们创建软链接，创建软链接应使用绝对路径。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 解压</span>\n<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> cmake-3.20.1-linux-x86_64.tar.gz\n<span class="token comment"># 为二进制文件创建软链接</span>\n<span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-sf</span> /path/to/cmake-3.20.1-linux-x86_64/bin/* /usr/bin/\n<span class="token comment"># 再次执行，确保安装成功</span>\ncmake <span class="token parameter variable">--version</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"查看版本号时如果提示 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">CMake Error: Could not find CMAKE_ROOT !!!</code>'}}),"，可能是原本调用的 CMake 二进制文件存放在其它目录下。例如，原来的 CMake 二进制文件存放在 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">/usr/local/bin/</code>'}})," 目录下，而调用命令时系统又优先从该目录搜索命令。因此应在创建软链接时应执行："),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 创建 cmake 二进制文件软链接</span>\n<span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-sf</span> /path/to/cmake-3.20.1-linux-x86_64/bin/* /usr/local/bin/</code></pre></div>'}}),"\n",t.createElement(a.p,null,"对于其它路径，可以通过 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">find / -name "cmake"</code>'}})," 来寻找。"),"\n",t.createElement(a.h2,null,"下载 gRPC"),"\n",t.createElement(a.p,null,"建议在能够直接访问外网的环境利用 git 克隆 gRPC 库并获取第三方依赖，再打包出来给其它环境编译使用。"),"\n",t.createElement(a.p,null,"手动下载 gRPC 及第三方依赖耗时耗力，还有可能像我一样“赔了夫人又折兵”依然编译不了。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 克隆 gRPC 仓库</span>\n<span class="token function">git</span> clone https://github.com/grpc/grpc.git\n<span class="token builtin class-name">cd</span> grpc\n<span class="token comment"># 获取 gRPC 第三方依赖</span>\n<span class="token function">git</span> submodule update <span class="token parameter variable">--init</span></code></pre></div>'}}),"\n",t.createElement(a.h2,null,"编译安装 gRPC"),"\n",t.createElement(a.p,null,"官方文档",t.createElement(a.a,{href:"https://grpc.io/docs/languages/cpp/quickstart/#build-and-install-grpc-protocol-buffers-and-abseil"},"建议"),"用户选择本地路径安装 gRPC，因为全局安装后想要卸载 gRPC 会十分复杂。因此，在编译安装之前，可以首先选择一个用户本地的路径。"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 安装到 $HOME/.local 中</span>\n<span class="token builtin class-name">export</span> <span class="token assign-left variable">MY_INSTALL_DIR</span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/.local\n<span class="token comment"># 确保目录存在</span>\n<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token variable">$MY_INSTALL_DIR</span>\n<span class="token comment"># 添加该路径下的 bin 目录到环境变量</span>\n<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$PATH</span>:<span class="token variable">$MY_INSTALL_DIR</span>/bin"</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"在 gRPC 根目录下执行",t.createElement(a.a,{href:"https://github.com/grpc/grpc/blob/master/BUILDING.md#building-with-cmake"},"下述操作"),"："),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 创建存放编译 gRPC 结果的目录</span>\n<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> cmake/build\n<span class="token comment"># 进入到该目录</span>\n<span class="token function">pushd</span> cmake/build\n<span class="token comment"># 生成编译 gRPC 的 Makefile 文件</span>\n<span class="token comment"># 其中 DCMAKE_INSTALL_PREFIX 指定了 gRPC 的安装路径</span>\ncmake <span class="token parameter variable">-DgRPC_INSTALL</span><span class="token operator">=</span>ON <span class="token punctuation">\\</span>\n    <span class="token parameter variable">-DgRPC_BUILD_TESTS</span><span class="token operator">=</span>OFF <span class="token punctuation">\\</span>\n    <span class="token parameter variable">-DCMAKE_INSTALL_PREFIX</span><span class="token operator">=</span><span class="token variable">$MY_INSTALL_DIR</span> <span class="token punctuation">\\</span>\n    <span class="token punctuation">..</span>/<span class="token punctuation">..</span>\n<span class="token comment"># 执行编译</span>\n<span class="token comment"># ${JOBS_NUM} 为同时执行的线程数，应替换为数字，下同</span>\n<span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token variable">${JOBS_NUM}</span>\n<span class="token comment"># 安装 gRPC</span>\n<span class="token function">make</span> <span class="token function">install</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"如果想要编译动态库 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">.so</code>'}})," 文件，可以在上一步执行 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">cmake</code>'}})," 命令时设置 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">-DBUILD_SHARED_LIBS=ON</code>'}}),"，如："),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 生成编译 gRPC 的 Makefile 文件</span>\ncmake <span class="token parameter variable">-DBUILD_SHARED_LIBS</span><span class="token operator">=</span>ON <span class="token punctuation">..</span>/<span class="token punctuation">..</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"假如编译失败，可以参考笔者遇到的",t.createElement(a.a,{href:"#%E5%8F%AF%E8%83%BD%E9%81%87%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF"},"错误和解决方案"),"。"),"\n",t.createElement(a.p,null,"C++ 版本的 gRPC 还依赖于 Abseil C++ 库，因此需要单独编译安装它："),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 回到 gRPC 根目录</span>\n<span class="token function">popd</span>\n<span class="token comment"># 创建存放 Abseil C++ 编译结果的目录</span>\n<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> third_party/abseil-cpp/cmake/build\n<span class="token comment"># 进入到编译目录</span>\n<span class="token function">pushd</span> third_party/abseil-cpp/cmake/build\n<span class="token comment"># 生成编译 abseil-cpp 的 Makefile 文件</span>\ncmake <span class="token parameter variable">-DCMAKE_INSTALL_PREFIX</span><span class="token operator">=</span><span class="token variable">$MY_INSTALL_DIR</span> <span class="token punctuation">\\</span>\n    <span class="token parameter variable">-DCMAKE_POSITION_INDEPENDENT_CODE</span><span class="token operator">=</span>TRUE <span class="token punctuation">\\</span>\n    <span class="token punctuation">..</span>/<span class="token punctuation">..</span>\n<span class="token comment"># 执行编译</span>\n<span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token variable">${JOBS_NUM}</span>\n<span class="token comment"># 安装 Abseil C++</span>\n<span class="token function">make</span> <span class="token function">install</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"哈！大功告成。最后我们来测试一下 gRPC 是否安装成功。"),"\n",t.createElement(a.h2,null,"测试编译安装 gRPC 成功"),"\n",t.createElement(a.p,null,"首先编译 gRPC 提供的示例："),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 回到 gRPC 根目录</span>\n<span class="token function">popd</span>\n<span class="token comment"># 进入 example 目录</span>\n<span class="token builtin class-name">cd</span> examples/cpp/helloworld\n<span class="token comment"># 创建存放 example 编译结果的目录</span>\n<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> cmake/build\n<span class="token comment"># 进入到编译目录</span>\n<span class="token function">pushd</span> cmake/build\n<span class="token comment"># 生成编译 example 的 Makefile 文件</span>\n<span class="token comment"># 其中 DCMAKE_PREFIX_PATH 指定我们使用的 gRPC 路径，即 gRPC 的安装路径</span>\ncmake <span class="token parameter variable">-DCMAKE_PREFIX_PATH</span><span class="token operator">=</span><span class="token variable">$MY_INSTALL_DIR</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>\n<span class="token comment"># 执行编译</span>\n<span class="token function">make</span> <span class="token parameter variable">-j</span> <span class="token variable">${JOBS_NUM}</span></code></pre></div>'}}),"\n",t.createElement(a.p,null,"这样，在当前目录就会生成编译好的二进制文件。试试看吧！"),"\n",t.createElement(a.p,null,"在当前终端启用 gRPC 示例的服务端，它会默认监听当前主机的 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">50051</code>'}})," 端口："),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">./greeter_server\n\n<span class="token comment"># 显示内容如下</span>\nServer listening on <span class="token number">0.0</span>.0.0:50051</code></pre></div>'}}),"\n",t.createElement(a.p,null,"打开一个新终端，进入到此目录，运行客户端，就可以看到访问的结果啦："),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">./greeter_client\n\n<span class="token comment"># 显示内容如下</span>\nGreeter received: Hello world</code></pre></div>'}}),"\n",t.createElement(a.p,null,"假如退出了服务端，再运行客户端，则会打印："),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token comment"># 关闭服务端，然后执行</span>\n./greeter_client\n\n<span class="token comment"># 显示内容如下</span>\n<span class="token number">14</span>: failed to connect to all addresses\nGreeter received: RPC failed</code></pre></div>'}}),"\n",t.createElement(a.p,null,"开始愉快地编写 gRPC 程序吧！"),"\n",t.createElement(a.h2,null,"可能遇见的错误"),"\n",t.createElement(a.h3,null,"编译 gRPC 执行 make 后提示 error"),"\n",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">error: no matching <span class="token keyword">function</span> <span class="token keyword">for</span> call to ‘StrFormat<span class="token punctuation">(</span>const char <span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span>, const char*, char <span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span>, int32_t<span class="token operator">&amp;</span>, long int<span class="token operator">&amp;</span>, const char*<span class="token operator">&amp;</span>, int<span class="token operator">&amp;</span><span class="token punctuation">)</span>’</code></pre></div>'}}),"\n",t.createElement(a.p,null,"提示报错没有找到 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">StrFormat</code>'}})," 函数，请确保 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gcc</code>'}})," 版本在 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">4.9</code>'}})," 及以上，可以执行 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gcc -v</code>'}})," 命令查看当前版本。"),"\n",t.createElement(a.p,null,"建议",t.createElement(a.a,{href:"http://3ms.huawei.com/km/blogs/details/10193429"},"更新"),"到 ",t.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">gcc 4.9.4</code>'}})," 版本，笔者在该版本下顺利编译 gRPC。"))}var c=function(e){void 0===e&&(e={});const{wrapper:a}=Object.assign({},(0,s.R)(),e.components);return a?t.createElement(a,e,t.createElement(l,e)):l(e)};var o=n(197),p=n(4353),r=n.n(p),m=n(4794),g=n(6947),u=n(4017),i=n(1042),d=n(1038);const k={a:e=>{let{href:a="",children:n}=e;const s=!(null!=a&&a.startsWith("#")),l=s?a:`#${encodeURIComponent(a.slice(1))}`;return t.createElement("a",{href:l,target:s?"_blank":void 0,rel:"noreferrer"},n)},img:e=>{const{alt:a="The author is too lazy to give an alt",src:n,...s}=e;return t.createElement("a",{href:n,"data-fancybox":"gallery","data-caption":a},t.createElement("img",Object.assign({src:n,alt:a},s)))},Card:g.A,Link:m.Link},h=e=>{let{children:a,data:n}=e;const{mdx:{frontmatter:{title:l,date:c,updated:p,categories:m,tags:g,timeliness:i}}}=n,h=t.useRef(null),b=r()(c),E=p?r()(p):b,_=r()().diff(E,"days");return t.useEffect((()=>{var e;const a=null===(e=h.current)||void 0===e?void 0:e.querySelectorAll("a.gatsby-resp-image-link");return null==a||a.forEach((e=>{const a=e.children.item(1);e.setAttribute("data-fancybox","gallery"),e.setAttribute("data-caption",a.alt)})),o.lX.bind("[data-fancybox]"),()=>o.lX.unbind("[data-fancybox]")}),[]),t.createElement("div",{className:"mx-auto flex max-w-xl flex-col gap-y-12"},t.createElement("div",{className:"flex flex-col gap-4"},(null==m?void 0:m.length)&&t.createElement(u.A,{name:m[0],className:"item-selectable"}),t.createElement("h1",{className:"text-3xl font-bold"},l),t.createElement("div",{className:"item-secondary flex flex-col gap-2 lg:flex-row"},c&&t.createElement("span",{title:`首次发布于：${b.toString()}\n最后更新于：${E.toString()}`},b.format("MM 月 DD 日 YYYY 年")),(null==g?void 0:g.length)&&t.createElement("div",{className:"flex flex-1 flex-wrap gap-2 lg:before:content-['•']"},g.map((e=>t.createElement(d.A,{key:e,name:e,className:"item-secondary item-selectable"})))))),t.createElement("article",{ref:h,className:"heti post-entry"},!1!==i&&_>365&&t.createElement("blockquote",{className:"border-l-4 border-orange-400"},"这是一篇",t.createElement("strong",null,"最后更新于 ",_," 天前"),"的博客，内容可能随着时间的推移而变得不再适用，建议您仔细评估信息的有效性。"),t.createElement(s.x,{components:k},a)))},b=e=>{let{data:a}=e;return t.createElement(i.A,{title:String(a.mdx.frontmatter.title)})};function E(e){return t.createElement(h,e,t.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-blog-posts-linux-docker-install-grpc-mdx-f16239b8c22a5065f693.js.map