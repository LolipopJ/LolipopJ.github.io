"use strict";(self.webpackChunkhomepage=self.webpackChunkhomepage||[]).push([[2342],{9704:function(e,t,n){n.r(t),n.d(t,{Head:function(){return f},default:function(){return v}});var l=n(8453),a=n(6540);function r(e){const t=Object.assign({p:"p",a:"a",blockquote:"blockquote",h2:"h2",h3:"h3",strong:"strong",h4:"h4",span:"span",ol:"ol",li:"li",ul:"ul"},(0,l.R)(),e.components),{Link:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Link",!0),a.createElement(a.Fragment,null,a.createElement(t.p,null,"V8 引擎是 Google 公司开发的开源 JavaScript 引擎，使用 C++ 语言编写，是目前最主流的 JavaScript 引擎，Chrome 和 Node.js 的底层都使用了 V8 引擎。了解 V8 引擎的工作过程和原理对一位前端工程师的重要程度不言而喻。"),"\n",a.createElement(t.p,null,"或者援引 Stack Overflow 创始人之一，艾林·约耳·斯波尔斯基的",a.createElement(t.a,{href:"https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/"},"博客"),"里的话来说："),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"由于抽象泄漏定律的存在，每当有人说自己发现了一款新的代码生成工具，能够大大提高我们的编程效率时，你会听很多人说“先学习手工编写，再去用工具生成”。代码生成工具是一种抽象，同样也会泄漏，唯一的解决方法是学习它的实现原理，即它抽象了什么。所以说抽象只是用于提高我们的工作效率的，而不会节省我们的学习时间。\n这就形成了一个悖论：当我们拥有越来越高级的开发工具，越来越好的“抽象”，要成为一个高水平的程序员反而越来越困难了。"),"\n"),"\n",a.createElement(t.p,null,"本篇博文将记录我学习 V8 引擎过程中的一些笔记和思考。"),"\n",a.createElement(t.h2,null,"JavaScript 语言类型"),"\n",a.createElement(t.p,null,"在进入正题之前，我想先对 JavaScript 语言类型做一些描述。"),"\n",a.createElement(t.h3,null,"编译型语言和解释型语言"),"\n",a.createElement(t.p,null,"现如今大多数程序员使用的语言都属于",a.createElement(t.strong,null,"高级语言"),"，如 C, C++, Java, Python, JavaScript 等，这些语言的编写更接近人的正常思维，可阅读性更好，实现相同功能需要的代码量更少，且更容易移植到不同平台上。但是，相较于机器语言和汇编语言此类",a.createElement(t.strong,null,"低级语言"),"，高级语言的代码运行效率相对较低，对硬件的可控程度也较弱。"),"\n",a.createElement(t.p,null,"每个程序都是一组指令，无论是简单的加减还是复杂的互联网请求，在执行之前都需要将人类可读的高级语言，转换为计算机可读的低级语言。由于转换过程的区别，我们通常又将高级语言划分为两类：",a.createElement(t.strong,null,"编译型语言"),"和",a.createElement(t.strong,null,"解释型语言"),"。不过，随着编程语言的发展，有的高级语言的执行过程结合了编译型语言和解释型语言的特性，称之为",a.createElement(t.strong,null,"混合型语言"),"。"),"\n",a.createElement(t.p,null,"对于编译型语言，目标计算机以编译语言直接翻译源代码，生成目标计算机可以执行的程序；对于解释型语言，目标计算机将源代码交给另一个程序（解释器）翻译并执行。用现实中的例子来讲就是："),"\n",a.createElement(t.blockquote,null,"\n",a.createElement(t.p,null,"想象你要制作一个鹰嘴豆泥食谱，但是它是用古希腊语写的。你不会讲古希腊语言，但是你可以通过两种方式遵循其指示。\n第一种方法是有人已经为你翻译成中文，你（以及其他会说中文的人）可以阅读食谱的中文版本，制作鹰嘴豆泥。那么翻译的配方就是",a.createElement(t.strong,null,"编译"),"版本。\n另一种方法是，如果你有一位了解古希腊语的朋友，当你准备制作鹰嘴豆泥时，你的朋友会坐在你的旁边，将菜谱逐行翻译成中文念出来。在这种情况下，你的朋友是食谱",a.createElement(t.strong,null,"解释"),"版本的解释者。"),"\n"),"\n",a.createElement(t.p,null,"编译型语言的优点是运行速度快，代码效率高，编译后程序看不到源码，保密性较高。除了你以外，其它会中文的人都可以参考这份中文食谱制作鹰嘴豆泥；缺点是需要经过编译才能使用，可移植性差，只能在兼容的系统上运行。假如鹰嘴豆泥食谱只有",a.createElement(t.a,{href:"https://zh.wikipedia.org/wiki/%E5%8F%A4%E9%AB%98%E5%9C%B0%E5%BE%B7%E8%AA%9E"},"古高地德语"),"的译版，不会古高地德语的你也就没法阅读它了。"),"\n",a.createElement(t.p,null,"解释型语言的优点是可移植性好，只要有解释器环境，程序就可以在不同系统上运行。你的朋友也可以坐在他的女朋友旁边，念给她这篇古希腊语食谱；缺点是代码执行需要专门的解释器，且每执行一次都需要翻译一次，运行效率较低。你需要一位会古希腊语的朋友，并且不厌其烦地念给你食谱上忘记的部分。"),"\n",a.createElement(t.p,null,"C, C++, Go 等就是典型的编译型语言，而 Java, Python, Matlab 等都属于解释型语言，至于 C#, .NET 则是混合型语言。那么 JavaScript 呢？"),"\n",a.createElement(t.h3,null,"JavaScript 是解释型语言还是编译型语言"),"\n",a.createElement(t.p,null,"MDN 指出：JavaScript 是一种具有函数优先的轻量级，",a.createElement(t.strong,null,"解释型"),"或即时编译型的编程语言。"),"\n",a.createElement(t.p,null,"或许你会抛出疑问，那么为什么 JavaScript 会出现变量提升（Hoisting）现象，又为什么会有及时编译器（Just-in-time compilers，通常简称 JIT）存在呢？"),"\n",a.createElement(t.h4,null,"解释变量提升"),"\n",a.createElement(t.p,null,a.createElement(n,{to:"/posts/js-hoisting"},"变量提升"),"\n，指函数作用域内的任何声明的变量都会被“提升”到顶部，并赋值为\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">undefined</code>'}}),"，这意味着在声明语句之前就可以使用这些变量了（后来 ES6 的 ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">let</code>'}})," 和\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">const</code>'}})," 命令解决了这个问题）。"),"\n",a.createElement(t.p,null,"这是否意味着 JavaScript 引擎解释同样的脚本文件两次？这显然会十分影响性能，且并不合理。还是意味着编译整个代码然后再运行它？其实也不是。这不过是解释器运行过程中执行上下文的小把戏罢了，以 V8 引擎为例："),"\n",a.createElement(t.ol,null,"\n",a.createElement(t.li,null,"一旦 V8 引擎进入一个执行具体代码的执行上下文，它就对代码进行词法分析或者分词。这意味着代码如 ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">var foo = 3;</code>'}})," 将被分割成像 ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">var</code>'}}),", ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">foo</code>'}}),", ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">=</code>'}}),", ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">3</code>'}})," 和 ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">;</code>'}})," 这样的 tokens。"),"\n",a.createElement(t.li,null,"在对当前的整个作用域分析完成后，引擎将这些 tokens 解析翻译成一个抽象语法树（AST）。"),"\n",a.createElement(t.li,null,"引擎每次遇到声明语句，就会把声明传到作用域中创建一个绑定。每次声明都会为变量分配内存，并赋予变量默认的 ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">undefined</code>'}})," 值。"),"\n",a.createElement(t.li,null,"在这之后，引擎每一次遇到赋值或者取值，都会通过作用域查找绑定。如果在当前作用域中没有查找到就接着向上级作用域查找，直到找到为止。"),"\n",a.createElement(t.li,null,"接着引擎生成 CPU 可以执行的机器码。"),"\n",a.createElement(t.li,null,"最后，执行机器码。"),"\n"),"\n",a.createElement(t.p,null,"因此，变量提升也只是 JavaScript 解释器执行中的一环。更进一步，变量提升其实是第一批 JavaScript 虚拟机的编译器在设计上的失误所致，只不过得以保留而已。"),"\n",a.createElement(t.h4,null,"解释 JIT"),"\n",a.createElement(t.p,null,"解释型语言和编译型语言的一个重要区别是，编译型语言需要较长的时间来准备执行，因为它需要对整个代码进行词法分析，执行优化等工作；而解释型语言几乎在执行后的一瞬间就开始，不会有代码优化的准备时间。考虑这一段代码："),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre></div>'}}),"\n",a.createElement(t.p,null,"在编译型语言里，循环体中的 ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">sum += 1</code>'}})," 部分在运行时已经编译成了机器码，机器码将执行 10000 次。"),"\n",a.createElement(t.p,null,"而在解释型语言里，如果没有进行代码优化，那么就需要将 ",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">sum += 1</code>'}})," 操作转换 1 次才执行 1 次，显然会造成非常巨大的性能损耗。这正是在 JavaScript 中加入 JIT 的原因之一。"),"\n",a.createElement(t.p,null,"如果 JavaScript 中的同一行代码运行了多次，就把它叫作温（warm）代码。如果运行了特别多次，则称作热（hot）代码。"),"\n",a.createElement(t.p,null,"如果一个函数开始“变温”，JIT 就会把这个函数送到",a.createElement(t.strong,null,"基准编译器"),"中编译并保存一个编译后的版本。下一次同样代码执行的时候，引擎就会跳过翻译过程而直接执行编译后的编码。"),"\n",a.createElement(t.p,null,"如果温代码运行次数越来越多，就成了热代码，JIT 会将热代码送到",a.createElement(t.strong,null,"优化编译器"),"中去，尝试更多地优化这段代码并保存优化后的版本。在这个过程中，优化编译器会做一些关于变量类型和运行环境中值的假设，如果这些假设成立就使用优化后的版本，使得效率进一步提高，如果不成立则回滚到上一版本。"),"\n",a.createElement(t.h3,null,"JavaScript 语言类型小结"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"JavaScript 代码依赖于 JavaScript 引擎才能执行，这是解释型语言所需要的。而编译型语言在编译后能够自由运行。"),"\n",a.createElement(t.li,null,"JavaScript 中变量提升不是代码修改，也没有生成中间代码，只不过是解释器工作的流程之一。"),"\n",a.createElement(t.li,null,"JIT 并不是完整的编译器，同样它也只在执行前进行编译。Mozilla 和 Google 的工程师引入 JIT 以改进浏览器性能，但 JavaScript 或 Ecma TC39 从未要求使用它。"),"\n"),"\n",a.createElement(t.p,null,"综上所述，尽管 JavaScript 执行时像是在编译或是一种编译和解释的混合，它仍然属于解释型语言，或者说如今很多人谈到的",a.createElement(t.strong,null,"混合型语言"),"。"),"\n",a.createElement(t.p,null,"现如今，编译和解释的技术不断发展，高级语言为了追求更强的兼容性或更出色的性能，会汲取二者的特性，发展成为更符合现代开发要求的语言。因此，关于高级语言的类型定义的界限可能会变得模糊，这时我们可以用混合型语言概括之，避免无谓的争端。"),"\n",a.createElement(t.h2,null,"V8 引擎概览"),"\n",a.createElement(t.p,null,"首先应指出的是，V8 引擎是一个仍在不断优化发展的项目，则对 V8 的学习也应该是动态渐进的。"),"\n",a.createElement(t.h2,null,"V8 引擎工作过程"),"\n",a.createElement(t.h2,null,"V8 引擎工作原理"),"\n",a.createElement(t.h3,null,"进一步学习 JIT"),"\n",a.createElement(t.h2,null,"JavaScript 与 TypeScript"),"\n",a.createElement(t.h2,null,"参考资料"),"\n",a.createElement(t.h3,null,"技术博文"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://chinese.freecodecamp.org/news/compiled-versus-interpreted-languages/"},"解释型语言和编译型语言的区别"),", 2021-01-06"),"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://segmentfault.com/a/1190000013126460"},"JavaScript 到底是解释型语言还是编译型语言?"),", 2019-07-30, 英文",a.createElement(t.a,{href:"https://www.voidcanvas.com/is-javascript-really-interpreted-or-compiled-language/"},"原文链接")),"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/"},"A crash course in just-in-time (JIT) compilers"),", 2017-02-28"),"\n"),"\n",a.createElement(t.h3,null,"其它资料"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://github.com/getify/You-Dont-Know-JS"},"You Don't Know Javascript")),"\n",a.createElement(t.li,null,a.createElement(t.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript"},"MDN Web Docs - JavaScript")),"\n"))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.R)(),e.components);return t?a.createElement(t,e,a.createElement(r,e)):r(e)};var s=n(197),o=n(4353),m=n.n(o),u=n(4810),p=n(6947),i=n(4017),E=n(1042),g=n(1038);const d={a:e=>{let{href:t="",children:n}=e;const l=!(null!=t&&t.startsWith("#")),r=l?t:`#${encodeURIComponent(t.slice(1))}`;return a.createElement("a",{href:r,target:l?"_blank":void 0,rel:"noreferrer"},n)},img:e=>{const{alt:t="The author is too lazy to give an alt",src:n,...l}=e;return a.createElement("a",{href:n,"data-fancybox":"gallery","data-caption":t},a.createElement("img",Object.assign({src:n,alt:t},l)))},Card:p.A,Link:u.N_},h=e=>{let{children:t,data:n}=e;const{mdx:{frontmatter:{title:r,date:c,updated:o,categories:u,tags:p,timeliness:E=!0}}}=n,h=a.useRef(null),f=m()(c),v=o?m()(o):f,S=m()().diff(v,"days");return a.useEffect((()=>{var e;const t=null===(e=h.current)||void 0===e?void 0:e.querySelectorAll("a.gatsby-resp-image-link");return null==t||t.forEach((e=>{const t=e.children.item(1);e.setAttribute("data-fancybox","gallery"),e.setAttribute("data-caption",t.alt)})),s.lX.bind("[data-fancybox]"),()=>s.lX.unbind("[data-fancybox]")}),[]),a.createElement("div",{className:"mx-auto flex max-w-xl flex-col gap-y-12"},a.createElement("div",{className:"flex flex-col gap-4"},(null==u?void 0:u.length)&&a.createElement(i.A,{name:u[0],className:"item-selectable"}),a.createElement("h1",{className:"text-3xl font-bold"},r),a.createElement("div",{className:"item-secondary flex flex-col gap-2 lg:flex-row"},c&&a.createElement("span",{title:`首次发布于：${f.toString()}\n最后更新于：${v.toString()}`},f.format("MM 月 DD 日 YYYY 年")),(null==p?void 0:p.length)&&a.createElement("div",{className:"flex flex-1 flex-wrap gap-2 lg:before:content-['•']"},p.map((e=>a.createElement(g.A,{key:e,name:e,className:"item-secondary item-selectable"})))))),a.createElement("article",{ref:h,className:"heti post-entry"},E&&S>365&&a.createElement("blockquote",{className:"border-l-4 border-orange-400"},"这是一篇",a.createElement("strong",null,"最后更新于 ",S," 天前"),"的博客，内容可能随着时间的推移而变得不再适用，建议您仔细评估信息的有效性。"),a.createElement(l.x,{components:d},t)))},f=e=>{let{data:t}=e;return a.createElement(E.A,{title:String(t.mdx.frontmatter.title)})};function v(e){return a.createElement(h,e,a.createElement(c,e))}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-blog-drafts-js-v-8-learning-mdx-5578861f2764f1e0b2c1.js.map